# tcp的time_wait为什么是2MSL
kernel=3.10 TCP_TIMEWAIT_LEN=60s --> MSL=30s

### 正常的4次挥手
```
      TCP A                                                TCP B

  1.  ESTABLISHED                                          ESTABLISHED

  2.  (Close)
      FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  --> CLOSE-WAIT

  3.  FIN-WAIT-2  <-- <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT

  4.                                                       (Close)
      TIME-WAIT   <-- <SEQ=300><ACK=101><CTL=FIN,ACK>  <-- LAST-ACK

  5.  TIME-WAIT   --> <SEQ=101><ACK=301><CTL=ACK>      --> CLOSED

  6.  (2 MSL)
      CLOSED
```

如果主动关闭方跳过TIME_WAIT直接进入CLOSED状态，或者在TIME_WAIT停留的时长不足，那么当被动关闭方早先发出的延迟重复包（数据包或者FIN包）到达后，就可能出现类似下面的问题：
* 旧的TCP连接已经不存在了，收到FIN包，主动关闭方只能回应RST包，被动关闭方不是优雅关闭
* 新的TCP连接被建立起来了，收到数据包，可能会干扰新连接

### 主动关闭方要在TIME_WAIT停留多久，才能保证被动关闭方不再发送FIN包？

如果被动关闭方一直没收到最后一个ACK，会一直重传FIN，重试次数由tcp_orphan_retries控制，默认值为0，实则代表8
* 主动关闭方需要等待的时长，取决于被动关闭方最后一次重传FIN间隔+1MSL，等待2MSL就要求被动关闭方重传间隔小于1MSL
* 挥手期间，默认初始重传间隔TCP_RTO_MIN=200ms，第7次重传FIN后，重传间隔是25.6s，25.6 < 1MSL
* 挥手期间，初始重传间隔有没可能是其他数值呢？


### 主动关闭方要在TIME_WAIT停留多久，才能保证被动关闭方延迟重复数据包消失在网络中？
* A端只有在接收到有序的FIN包，才会进入TIME_WAIT，B端有两种情况可以回复FIN
  * 数据发送完，再发送FIN
  * 数据还没发送完，发送FIN


挥手前的延迟重复数据包
* 传输数据时，重传间隔由TCP_RTO_MIN=200ms、TCP_RTO_MAX=120s和实际RTO决定
* 假设B端的数据包丢失在网络中，N次重传后，重传间隔已达到最大值TCP_RTO_MAX=120s
  * A端开始接收到数据包，回复的ACK丢失了，B端发起N+1次重传
  * A端开始接收到数据包，回复的ACK在N+1次重传之前到达，B端不会发起N+1次重传
  * A端开始接收到数据包，在系统中卡了很久后，回复的ACK在N+1次重传之后到达，B端发起最后一次重传，该数据包最大生存时间为1MSL
* 假设A端的数据确认包丢失在网络中，B端发起重传

挥手前后交叉的重复数据包
* 挥手前B端的数据包没收到ACK，N次重传后，重传间隔已达到最大值TCP_RTO_MAX=120s
* A端发起的FIN在N+1次重传之前到达
  * 若B端没收到数据包的ACK，还是会重传数据包，不会对FIN回复ACK，A端也就没机会进入TIME_WAIT
  * 若B端收到数据的ACK，不会发起N+1次重传
* A端发起的FIN在N+1次重传之后到达，发起最后一次重传，该数据包最大生存时间为1MSL

挥手期的延迟重复数据包
* B端在回复FIN前，还有数据要传输给对方
* 数据包和FIN都丢失在网络中，A端在FIN_WAIT2等待tcp_fin_timeout
* 数据包丢失在网络中，FIN包到达了A端，A端并不会立即回复ACK进入TIME_WAIT，而是根据FIN包的确认号等待丢失的数据包