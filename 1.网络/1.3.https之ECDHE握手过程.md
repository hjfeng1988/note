# https ECDHE握手过程

1. 客户端发送`client hello`，包含`客户端随机数`等。

2. 服务端生成`临时服务端非对称密钥`，用`服务端私钥0`对`临时服务端公钥`的摘要值加密；

   回复`server hello`+`服务器数字证书`+`server Key exchange`+`server hello done`，`server hello`包含`服务端随机数`等；
   
   `server Key exchange`包含`临时服务端公钥`和它的摘要值密文。

3. 客户端验证`服务器数字证书`，若通过则拿到真实的`服务端公钥0`；再用`服务端公钥0`验证`临时服务端公钥`的真实性。
   
   客户端生成`临时客户端非对称密钥`，利用`临时客户端私钥`+`临时服务端公钥`等计算出`x值`，`x值`+`客户端随机数`+`服务端随机数`生成最终的`会话密钥`；
   
   客户端发送`client key exchange`+`客户端Encrypted Handshake Message`。

   `client key exchange`包含`临时客户端公钥`。

4. 服务端利用`临时服务端私钥`+`临时客户端公钥`等计算出`x值`，`x值`+`客户端随机数`+`服务端随机数`生成最终的`会话密钥`；

   服务端回复`服务端Encrypted Handshake Message`。

* 为何有了RSA算法，还要ECDHE算法
  * 因为RSA算法不支持前向安全，如果中间人截获了历史数据密文，也获得服务器RSA私钥，那么就可解密历史明文；ECDHE每次的连接主要依靠临时的非对称密钥，泄露密钥对0+临时服务端私钥只能解密当次的连接数据，以往的临时服务端私钥获取不到，就不会对历史数据造成影响。

* 为什么第3步的`client key exchange`没有包含摘要值密文？

  * 因为签名和验签需要对方有真实的公钥，而服务端此时没有持有与客户端私钥成对的公钥。如果客户端用`服务端公钥0`签名，中间人同样持有`服务端公钥0`，就可以伪造`临时客户端公钥`。既然防止不了伪造，就没必要签名了。
